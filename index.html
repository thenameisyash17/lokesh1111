<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Face Look — Shape Detection + Strict Acceptance</title>
<style>
  :root{--ok:#22c55e;--bad:#ef4444;--muted:#94a3b8}
  html,body{height:100%;margin:0;font-family:Inter,Arial;background:#071024;color:#e6eef6}
  .wrap{max-width:980px;margin:28px auto;padding:18px;border-radius:12px}
  .top{display:flex;gap:16px}
  .stage{position:relative;width:640px;height:480px;background:#000;border-radius:12px;overflow:hidden}
  canvas{position:absolute;left:0;top:0;width:100%;height:100%}
  .controls{flex:1;min-width:300px;padding:8px}
  .card{background:rgba(255,255,255,0.03);padding:12px;border-radius:8px}
  input,button,select{width:100%;padding:8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit}
  .banner{padding:10px;border-radius:8px;margin-bottom:10px;text-align:center;font-weight:700}
  .ok{background:var(--ok);color:#051014}
  .bad{background:var(--bad);color:#fff}
  pre{background:#041018;padding:8px;border-radius:6px;max-height:200px;overflow:auto}
  .small{font-size:13px;color:var(--muted);margin-top:8px}
  .shape{font-size:18px;font-weight:700;margin-top:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="stage card" id="stage">
      <canvas id="preview" width="640" height="480"></canvas>
      <canvas id="overlay" width="640" height="480" style="pointer-events:none"></canvas>
      <div id="banner" style="display:none" class="banner"></div>
    </div>
    <div class="controls">
      <div class="card">
        <label>Upload image (≤8MB)</label>
        <input id="upload" type="file" accept="image/*">
        <label class="small">Face area threshold (%)</label>
        <input id="area" type="range" min="0.5" max="10" step="0.5" value="3">
        <div id="areaLabel" class="small">3%</div>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="recheck">Re-check</button>
          <button id="clear">Clear</button>
        </div>
        <div class="shape" id="shapeText">Face shape: —</div>
        <div class="small">Result (JSON)</div>
        <pre id="out">{} </pre>
        <div class="small">Shape classification uses three horizontal widths (top/cheek/jaw) and length/width ratios. It's heuristic — verify with several photos.</div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
/* Helpers & DOM */
const $ = id => document.getElementById(id);
const preview = $('preview'), pctx = preview.getContext('2d');
const overlay = $('overlay'), octx = overlay.getContext('2d');
const upload = $('upload'), out = $('out'), banner = $('banner');
const area = $('area'), areaLabel = $('areaLabel'), shapeText = $('shapeText');
let uploadedCanvas = null;

area.addEventListener('input', ()=> areaLabel.textContent = area.value + '%');

function showBanner(ok, text){
  banner.style.display = 'block';
  banner.className = ok ? 'banner ok' : 'banner bad';
  banner.textContent = text;
}
function clearBanner(){ banner.style.display='none'; banner.textContent=''; }
function setOutput(obj){ out.textContent = JSON.stringify(obj, null, 2); console.log('EVALUATION:', obj); }

/* Landmark utilities */
function computeBoxFromLandmarks(landmarks, canvasEl){
  let minX=1,minY=1,maxX=0,maxY=0;
  for (const p of landmarks){
    if (typeof p.x !== 'number' || typeof p.y !== 'number') continue;
    if (!isFinite(p.x)||!isFinite(p.y)) continue;
    minX = Math.min(minX, p.x);
    minY = Math.min(minY, p.y);
    maxX = Math.max(maxX, p.x);
    maxY = Math.max(maxY, p.y);
  }
  const w = canvasEl.width, h = canvasEl.height;
  return { x: minX * w, y: minY * h, w: Math.max(0,(maxX-minX)*w), h: Math.max(0,(maxY-minY)*h) };
}

const CORE_IDXS = [33,263,1,13,14]; // left eye, right eye, nose tip, mouth upper/lower
function coreLandmarksVisible(landmarks){
  for (const idx of CORE_IDXS){
    const p = landmarks[idx];
    if (!p || !isFinite(p.x) || !isFinite(p.y)) return false;
  }
  return true;
}

/* face-shape measurement: compute widths at three relative heights and length */
function measureFace(landmarks, canvasEl){
  // landmarks are normalized wrt source image used by model (we pass uploadedCanvas)
  // compute minY and maxY normalized
  let minY=1, maxY=0;
  for (const p of landmarks){ if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; }
  const heightN = maxY - minY;
  if (!(heightN > 0)) return null;
  // sample three Y positions: top = minY + 0.12*height, cheek = minY + 0.45*height, jaw = minY + 0.8*height
  const yNorms = [minY + 0.12*heightN, minY + 0.45*heightN, minY + 0.80*heightN];
  const widths = [];
  for (const yTarget of yNorms){
    // find landmarks near this yTarget; expand band if necessary
    let band = 0.015;
    let left = 1, right = 0;
    let found = false;
    for (let attempt=0; attempt<6; attempt++){
      left = 1; right = 0; found = false;
      for (const p of landmarks){
        if (Math.abs(p.y - yTarget) <= band){
          left = Math.min(left, p.x);
          right = Math.max(right, p.x);
          found = true;
        }
      }
      if (found) break;
      band *= 2;
    }
    if (!found) {
      // fallback: approximate left/right from min/max x of all points
      let minX=1,maxX=0;
      for (const p of landmarks){ minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); }
      widths.push({normW: maxX - minX, leftN: minX, rightN: maxX});
    } else {
      widths.push({normW: right - left, leftN: left, rightN: right});
    }
  }
  // face length normalized:
  const lengthN = heightN;
  // convert to pixels for source canvas:
  const wPx = canvasEl.width, hPx = canvasEl.height;
  const widthsPx = widths.map(w => ({px: w.normW * wPx, left: w.leftN * wPx, right: w.rightN * wPx}));
  const lengthPx = lengthN * hPx;
  return { lengthPx, widthsPx, widthsNorm: widths.map(w=>w.normW), lengthNorm: lengthN };
}

/* classify shape using heuristics */
function classifyShape(measure){
  if (!measure) return {shape:'unknown', scores:null};
  const top = measure.widthsNorm[0], cheek = measure.widthsNorm[1], jaw = measure.widthsNorm[2];
  const len = measure.lengthNorm;
  const avgWidth = (top + cheek + jaw)/3;
  const lenOverWidth = len / avgWidth;
  // compute normalized ratios
  const jawToCheek = jaw / cheek;
  const topToCheek = top / cheek;
  // heuristics (ordered)
  if (lenOverWidth > 1.4) return {shape:'oblong/long', reason:`len/width=${lenOverWidth.toFixed(2)}`};
  // round: len ~ width and widths similar
  if (lenOverWidth >= 0.9 && lenOverWidth <= 1.15 && Math.abs(top-cheek) < 0.06 && Math.abs(cheek-jaw) < 0.06) return {shape:'round', reason:`len/width=${lenOverWidth.toFixed(2)}`};
  // square: len ~ width and jaw ~ cheek ~ top but angular — here jaw close to cheek and len similar
  if (lenOverWidth >= 0.9 && lenOverWidth <= 1.15 && Math.abs(jawToCheek - 1) < 0.08) return {shape:'square', reason:`jaw/cheek=${jawToCheek.toFixed(2)}`};
  // heart: top > cheek and jaw noticeably narrower
  if (topToCheek > 1.06 && jawToCheek < 0.9) return {shape:'heart', reason:`top/cheek=${topToCheek.toFixed(2)}, jaw/cheek=${jawToCheek.toFixed(2)}`};
  // diamond: cheek is largest, top and jaw narrower
  if (cheek > top && cheek > jaw && Math.abs(top - jaw) < 0.12) return {shape:'diamond', reason:`cheek largest`};
  // oval: len > width and jaw narrower than cheek
  if (lenOverWidth > 1.15 && jawToCheek < 0.95) return {shape:'oval', reason:`len/width=${lenOverWidth.toFixed(2)}, jaw/cheek=${jawToCheek.toFixed(2)}`};
  // fallback: choose closest by ratios
  // prefer oval if len slightly > width
  if (lenOverWidth > 1.15) return {shape:'oval', reason:`fallback len/width=${lenOverWidth.toFixed(2)}`};
  return {shape:'unknown', reason:'no heuristic matched'};
}

/* draw measurement guides on overlay (scaled to preview) */
function drawMeasureGuides(measure, srcCanvas){
  octx.clearRect(0,0,overlay.width,overlay.height);
  if (!measure) return;
  const sx = overlay.width / srcCanvas.width;
  const sy = overlay.height / srcCanvas.height;
  octx.lineWidth = 2;
  // draw horizontal lines and labels for top/cheek/jaw
  const colors = ['#f59e0b','#06b6d4','#ef4444'];
  ['Top','Cheek','Jaw'].forEach((label,i)=>{
    const w = measure.widthsPx[i];
    const y = ( (w.left + w.right) ? ( (w.left + w.right)/2 ) : ( (measure.lengthPx/2) ) ); // not used
    // calculate y position using the normalized positions: average y of landmarks in that band would be better but we don't have that; we'll estimate by using left/right midpoints' y derived from their normalized indices earlier is not present — instead compute y from canvas: use proportional positions from widthsNorm indices
    // Simpler: compute normalized y from earlier method by mapping stored normalized positions: we'll instead compute an approximate y by scanning landmarks - but to keep it simple draw lines at relative vertical fractions: top ~ 0.12, cheek ~0.45, jaw ~0.8 of preview height within face bbox
  });
  // Instead compute face bbox on src canvas and draw lines relative to that
  // Attempt to compute normalized bbox from landmarks again:
  // find minY/maxY from uploaded canvas landmarks (we require that be available as measure provides lengthNorm)
  // We'll draw 3 horizontal lines inside the face vertical span:
  const previewW = overlay.width, previewH = overlay.height;
  const faceTopY = previewH * ( (1 - measure.lengthNorm)/2 + 0.05 ); // approximate centering — simpler: put lines relative to preview height
  const topY = previewH * 0.28;
  const cheekY = previewH * 0.50;
  const jawY = previewH * 0.72;
  [topY,cheekY,jawY].forEach((yy,i) => {
    octx.strokeStyle = colors[i];
    octx.beginPath();
    octx.moveTo(8, yy);
    octx.lineTo(previewW-8, yy);
    octx.stroke();
    octx.fillStyle = colors[i];
    octx.font = '12px sans-serif';
    octx.fillText(['Top','Cheek','Jaw'][i], 12, yy - 6);
  });
  // draw small legend of pixel widths
  octx.fillStyle = '#fff';
  octx.font = '12px sans-serif';
  octx.fillText(`Top:${Math.round(measure.widthsPx[0].px)}px Cheek:${Math.round(measure.widthsPx[1].px)}px Jaw:${Math.round(measure.widthsPx[2].px)}px Len:${Math.round(measure.lengthPx)}px`, 10, overlay.height - 12);
}

/* Strict acceptance logic (same as earlier) */
function evaluateDetection(results, sourceCanvas, areaThresholdPct){
  const faces = results.multiFaceLandmarks || [];
  const imageArea = sourceCanvas.width * sourceCanvas.height;
  const response = { accepted:false, reason:'no_face', faces: faces.length, bbox:null, shape:'unknown', measures:null, checks:{} };

  if (faces.length === 0){
    response.reason = 'no_face';
    response.checks.faces = 0;
    return response;
  }
  if (faces.length !== 1){
    response.reason = 'multiple_faces';
    response.checks.faces = faces.length;
    return response;
  }
  const landmarks = faces[0];
  response.checks.coreLandmarksPresent = coreLandmarksVisible(landmarks);
  if (!response.checks.coreLandmarksPresent){
    response.reason = 'core_landmarks_missing';
    return response;
  }
  const box = computeBoxFromLandmarks(landmarks, sourceCanvas);
  response.bbox = { x: Math.round(box.x), y: Math.round(box.y), w: Math.round(box.w), h: Math.round(box.h) };
  if (!isFinite(box.w) || !isFinite(box.h) || box.w <= 0 || box.h <= 0){
    response.reason = 'invalid_bbox';
    return response;
  }
  const boxArea = box.w * box.h;
  const thresholdArea = (areaThresholdPct/100) * imageArea;
  response.checks.boxPixels = boxArea;
  response.checks.imagePixels = imageArea;
  response.checks.thresholdPixels = thresholdArea;
  if (boxArea < thresholdArea) { response.reason = 'face_too_small'; return response; }
  if (box.w < 10 || box.h < 10) { response.reason = 'bbox_too_narrow'; return response; }

  // all basic checks passed -> measure & classify
  const measure = measureFace(landmarks, sourceCanvas);
  response.measures = measure;
  const cls = classifyShape(measure);
  response.shape = cls.shape;
  response.shapeReason = cls.reason;

  response.accepted = true;
  response.reason = 'one_face_detected';
  return response;
}

/* MediaPipe setup */
const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
faceMesh.setOptions({ maxNumFaces: 2, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

faceMesh.onResults(async (results) => {
  if (!uploadedCanvas) { setOutput({accepted:false,reason:'no_source'}); showBanner(false,'No image'); return; }
  const res = evaluateDetection(results, uploadedCanvas, parseFloat(area.value));
  setOutput(res);
  shapeText.textContent = 'Face shape: ' + (res.shape || '—');
  if (!res.accepted){
    showBanner(false, res.reason.replace(/_/g,' ').toUpperCase());
    octx.clearRect(0,0,overlay.width, overlay.height);
    // if faces exist, draw their boxes scaled to preview for debugging
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0){
      for (const f of results.multiFaceLandmarks){
        drawOverlayForFace(f, uploadedCanvas);
      }
    }
    return;
  }
  showBanner(true, 'ACCEPTED — ' + res.shape.toUpperCase());
  // draw overlay with measurements scaled to preview
  drawOverlayForFace(results.multiFaceLandmarks[0], uploadedCanvas);
  const measure = res.measures;
  if (measure) {
    drawMeasureGuides(measure, uploadedCanvas);
  }
});

/* helper: draw overlay scaled to preview (points + bbox) */
function drawOverlayForFace(landmarks, srcCanvas){
  octx.clearRect(0,0,overlay.width, overlay.height);
  if (!landmarks) return;
  const sx = overlay.width / srcCanvas.width;
  const sy = overlay.height / srcCanvas.height;
  // draw points
  octx.fillStyle = '#FFDD77';
  for (const p of landmarks){
    const px = p.x * srcCanvas.width * sx;
    const py = p.y * srcCanvas.height * sy;
    octx.beginPath();
    octx.arc(px, py, 1.6, 0, Math.PI*2);
    octx.fill();
  }
  // draw bbox
  const box = computeBoxFromLandmarks(landmarks, srcCanvas);
  octx.strokeStyle = '#06b6d4';
  octx.lineWidth = 2;
  octx.strokeRect(box.x * sx, box.y * sy, box.w * sx, box.h * sy);
}

/* Load file -> create uploadedCanvas (source-of-truth) -> preview -> send to faceMesh */
function loadImageFile(file){
  return new Promise((resolve,reject) => {
    if (!file) return reject('no_file');
    if (file.size > 8 * 1024 * 1024) return reject('file_too_large');
    const img = new Image();
    img.onload = () => {
      const c = document.createElement('canvas');
      c.width = img.naturalWidth;
      c.height = img.naturalHeight;
      const cx = c.getContext('2d');
      cx.drawImage(img,0,0);
      resolve(c);
      URL.revokeObjectURL(img.src);
    };
    img.onerror = ()=> reject('invalid_image');
    img.src = URL.createObjectURL(file);
  });
}

function drawPreviewFromSource(srcCanvas){
  if (!srcCanvas) return;
  const sw = preview.clientWidth, sh = preview.clientHeight;
  const scale = Math.min(sw / srcCanvas.width, sh / srcCanvas.height);
  preview.width = Math.round(srcCanvas.width * scale);
  preview.height = Math.round(srcCanvas.height * scale);
  overlay.width = preview.width;
  overlay.height = preview.height;
  pctx.clearRect(0,0,preview.width,preview.height);
  pctx.drawImage(srcCanvas, 0, 0, preview.width, preview.height);
}

/* UI flows */
upload.addEventListener('change', async (e) => {
  clearBanner(); octx.clearRect(0,0,overlay.width,overlay.height); setOutput({});
  shapeText.textContent = 'Face shape: —';
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  try {
    uploadedCanvas = await loadImageFile(f);
  } catch (err){
    showBanner(false, 'Invalid image or too large');
    setOutput({accepted:false,reason:'invalid_image'});
    return;
  }
  drawPreviewFromSource(uploadedCanvas);
  try {
    await faceMesh.send({image: uploadedCanvas});
  } catch (err){
    console.error(err);
    showBanner(false,'Model error');
    setOutput({accepted:false,reason:'model_error',error:String(err)});
  }
});

$('recheck').addEventListener('click', async () => {
  if (!uploadedCanvas) { showBanner(false,'No image'); return; }
  clearBanner(); octx.clearRect(0,0,overlay.width,overlay.height);
  try { await faceMesh.send({image: uploadedCanvas}); } catch(e){ console.error(e); showBanner(false,'Model error'); }
});

$('clear').addEventListener('click', () => {
  uploadedCanvas = null;
  pctx.clearRect(0,0,preview.width, preview.height);
  octx.clearRect(0,0,overlay.width, overlay.height);
  $('upload').value = '';
  clearBanner();
  setOutput({});
  shapeText.textContent = 'Face shape: —';
});

/* init canvas */
(function init(){
  preview.width = 640; preview.height = 480; overlay.width = 640; overlay.height = 480;
  pctx.fillStyle = '#020814'; pctx.fillRect(0,0,preview.width, preview.height);
  pctx.fillStyle = '#6b7280'; pctx.font = '14px Inter, sans-serif';
  pctx.fillText('Upload image to analyze face shape', 14, 28);
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Face-Look — Live Face Detector + Face Shape</title>
<style>
  :root{
    --bg:#020617;
    --bg-soft:#020718;
    --panel:#020617;
    --card:rgba(15,23,42,0.95);
    --muted:#94a3b8;
    --ok:#22c55e;
    --bad:#ef4444;
    --accent:#06b6d4;
    --accent-soft:rgba(56,189,248,0.25);
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Inter",sans-serif;
    background:radial-gradient(circle at top,var(--bg-soft),var(--bg));
    color:#e5e7eb;
  }
  .wrap{
    max-width:1180px;
    margin:16px auto;
    padding:12px 16px 24px;
  }
  .head{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
    gap:12px;
  }
  .titleBlock h1{
    margin:0;
    font-size:22px;
    letter-spacing:0.03em;
  }
  .titleBlock p{
    margin:4px 0 0;
    font-size:13px;
    color:var(--muted);
  }
  .pillRow{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .pill{
    padding:4px 10px;
    border-radius:999px;
    font-size:11px;
    border:1px solid rgba(148,163,184,0.4);
    background:rgba(15,23,42,0.85);
  }

  .cols{
    display:flex;
    gap:16px;
    align-items:flex-start;
    flex-wrap:wrap;
  }

  .stageCard{
    flex:1.5 1 340px;
    background:radial-gradient(circle at top,var(--accent-soft),var(--card));
    border-radius:18px;
    padding:10px;
    position:relative;
    box-shadow:0 18px 45px rgba(15,23,42,0.9);
    border:1px solid rgba(148,163,184,0.35);
  }

  .stage{
    position:relative;
    width:100%;
    aspect-ratio:4/3;
    background:#020617;
    border-radius:14px;
    overflow:hidden;
  }
  canvas{
    position:absolute;
    inset:0;
    display:block;
  }
  #previewCanvas{background:#020617;}
  .overlay{pointer-events:none}

  #spinner{
    position:absolute;
    left:12px;
    top:12px;
    padding:6px 10px;
    border-radius:999px;
    background:rgba(15,23,42,0.85);
    border:1px solid rgba(148,163,184,0.45);
    font-size:11px;
    display:none;
  }
  #modeBadge{
    position:absolute;
    right:12px;
    top:12px;
    padding:5px 10px;
    border-radius:999px;
    font-size:11px;
    border:1px solid rgba(148,163,184,0.45);
    background:rgba(15,23,42,0.85);
  }
  #statusDot{
    width:8px;
    height:8px;
    border-radius:999px;
    display:inline-block;
    margin-right:6px;
    background:#ef4444;
  }
  #banner{
    position:absolute;
    left:50%;
    bottom:12px;
    transform:translateX(-50%);
    min-width:60%;
    text-align:center;
    padding:8px 12px;
    border-radius:999px;
    font-size:12px;
    display:none;
    font-weight:600;
  }
  .banner.ok{
    background:rgba(22,163,74,0.95);
    color:#ecfdf3;
  }
  .banner.bad{
    background:rgba(220,38,38,0.98);
    color:#fee2e2;
  }

  .controlsCol{
    flex:1 1 320px;
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .card{
    background:var(--card);
    padding:12px;
    border-radius:14px;
    border:1px solid rgba(15,23,42,0.9);
    box-shadow:0 10px 30px rgba(15,23,42,0.9);
  }
  .cardHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:6px;
  }
  .cardHeader h2{
    margin:0;
    font-size:14px;
    letter-spacing:0.04em;
    text-transform:uppercase;
    color:#e5e7eb;
  }
  .cardHeader span{
    font-size:11px;
    color:var(--muted);
  }

  label{
    display:block;
    color:var(--muted);
    font-size:12px;
    margin-top:8px;
    margin-bottom:3px;
  }
  input[type=file],
  button,
  select,
  input[type=range],
  input[type=number]{
    width:100%;
    padding:8px 9px;
    border-radius:8px;
    background:rgba(15,23,42,0.95);
    border:1px solid rgba(51,65,85,0.9);
    color:#e5e7eb;
    font-size:13px;
    outline:none;
  }
  input[type=range]{
    padding:0;
    accent-color:var(--accent);
    height:4px;
  }
  input[type=range]::-webkit-slider-thumb{
    cursor:pointer;
  }
  button{
    cursor:pointer;
    transition:background 0.12s ease,transform 0.08s ease,box-shadow 0.12s ease,border-color 0.12s ease;
    font-weight:500;
  }
  button:hover{
    transform:translateY(-1px);
    box-shadow:0 8px 18px rgba(15,23,42,0.9);
    border-color:rgba(148,163,184,0.7);
  }
  button:active{
    transform:translateY(0);
    box-shadow:none;
  }
  .btnPrimary{
    background:linear-gradient(135deg,#06b6d4,#22c55e);
    border-color:transparent;
    color:#020617;
  }
  .btnGhost{
    background:rgba(15,23,42,0.9);
  }
  .btnDanger{
    background:rgba(127,29,29,0.95);
    border-color:rgba(185,28,28,0.9);
  }

  .row{
    display:flex;
    gap:8px;
    margin-top:8px;
  }
  .small{
    font-size:12px;
    color:var(--muted);
    margin-top:6px;
  }

  .shape{
    font-weight:600;
    font-size:14px;
    margin-top:4px;
  }
  .quality{
    font-weight:600;
    font-size:13px;
    margin-top:2px;
  }
  .metricLine{
    font-size:12px;
    margin-top:4px;
    color:var(--muted);
  }
  .badge{
    display:inline-flex;
    align-items:center;
    gap:4px;
    padding:3px 8px;
    border-radius:999px;
    font-size:11px;
    border:1px solid rgba(148,163,184,0.5);
    background:rgba(15,23,42,0.8);
    margin-right:4px;
  }
  .badgeDot{
    width:7px;
    height:7px;
    border-radius:999px;
    background:#22c55e;
  }

  pre{
    background:#020617;
    border-radius:10px;
    padding:9px;
    max-height:210px;
    overflow:auto;
    font-size:11px;
    line-height:1.5;
    border:1px solid rgba(30,64,175,0.7);
  }

  .insightTitle{
    font-size:13px;
    font-weight:600;
    margin-top:4px;
  }
  .insightList{
    margin:4px 0 0;
    padding-left:16px;
    font-size:12px;
    color:var(--muted);
  }
  .insightList li{
    margin-bottom:2px;
  }

  #liveHint{
    font-size:11px;
    color:var(--muted);
    margin-top:4px;
  }

  @media (max-width:720px){
    .stageCard{order:-1;}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="head">
    <div class="titleBlock">
      <h1>Face-Look Live</h1>
      <p>Real-time face detector with face-shape insights and quality scoring.</p>
    </div>
    <div class="pillRow">
      <div class="pill">Single-face only</div>
      <div class="pill">Face shape heuristics</div>
      <div class="pill">Live + upload modes</div>
    </div>
  </div>

  <div class="cols">
    <div class="stageCard">
      <div class="stage" id="stage">
        <canvas id="previewCanvas"></canvas>
        <canvas id="overlay" class="overlay"></canvas>
        <div id="spinner">Analyzing…</div>
        <div id="modeBadge"><span id="statusDot"></span><span id="modeText">Idle</span></div>
        <div id="banner" aria-live="polite" role="status"></div>
        <video id="video" playsinline muted style="display:none"></video>
      </div>
    </div>

    <div class="controlsCol">
      <div class="card">
        <div class="cardHeader">
          <h2>Capture</h2>
          <span>Step 1 · Choose live or upload</span>
        </div>

        <label>Live camera</label>
        <div class="row">
          <button id="startLive" type="button" class="btnPrimary">Start live camera</button>
          <button id="stopLive" type="button" class="btnGhost">Stop</button>
        </div>
        <div id="liveHint">Allow camera permission, keep your face centered, and look straight.</div>

        <label for="upload">Or upload a photo (≤8MB)</label>
        <input id="upload" type="file" accept="image/*">

        <label for="areaRange">Area threshold (%)</label>
        <input id="areaRange" type="range" min="0.5" max="10" step="0.5" value="3">
        <div class="small" id="areaLabel">3%</div>

        <label for="blurRange">Blur threshold (Laplacian variance)</label>
        <input id="blurRange" type="range" min="10" max="1000" step="10" value="100">
        <div class="small" id="blurLabel">100</div>

        <label>Angle thresholds (degrees)</label>
        <div class="row">
          <input id="rollThresh" type="number" value="20" min="0" max="45" aria-label="Roll threshold (degrees)" />
          <input id="yawThresh" type="number" value="15" min="0" max="45" aria-label="Yaw threshold (degrees)" />
        </div>
        <div class="small">Roll / yaw limits. Higher values accept more head tilt/turn.</div>

        <div class="row">
          <button id="recheck" type="button" class="btnGhost">Re-check current frame</button>
          <button id="clear" type="button" class="btnDanger">Clear</button>
        </div>

        <div class="small">Rules: single-face, min area, core landmarks present, blur above threshold, roll/yaw within limits.</div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h2>Analysis</h2>
          <span>Step 2 · Shape & metrics</span>
        </div>
        <div class="shape" id="shapeText">Face shape: —</div>
        <div class="quality" id="qualityText">Quality score: —</div>
        <div class="metricLine" id="metrics">Area ratio: — | Blur: — | Roll: — | Yaw: — | Jaw: —°</div>
        <div class="small" id="summaryText">No analysis yet.</div>

        <div class="small" style="margin-top:10px">
          <span class="badge"><span class="badgeDot" id="qDot"></span><span id="qLabel">Idle</span></span>
          <span class="badge" id="shapeBadge" style="display:none;"></span>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h2>Face insights</h2>
          <span>Step 3 · Smart hints</span>
        </div>
        <div class="insightTitle">What your face says:</div>
        <ul class="insightList" id="insights">
          <li>Start the camera or upload a photo to see tailored tips.</li>
        </ul>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h2>Result JSON</h2>
          <span>Debug · Integrations</span>
        </div>
        <pre id="jsonOut">{}</pre>
        <div class="row" style="margin-top:6px">
          <button id="copyJson" type="button" class="btnGhost">Copy JSON</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
const $ = id => document.getElementById(id);

const preview = $('previewCanvas');
const pctx = preview.getContext('2d');
const overlay = $('overlay');
const ctx = overlay.getContext('2d');
const upload = $('upload');
const spinner = $('spinner');
const banner = $('banner');
const jsonOut = $('jsonOut');
const shapeText = $('shapeText');
const qualityText = $('qualityText');
const summaryText = $('summaryText');
const metrics = $('metrics');
const areaRange = $('areaRange');
const areaLabel = $('areaLabel');
const blurRange = $('blurRange');
const blurLabel = $('blurLabel');
const recheckBtn = $('recheck');
const clearBtn = $('clear');
const copyJsonBtn = $('copyJson');
const rollThreshInput = $('rollThresh');
const yawThreshInput = $('yawThresh');
const startLiveBtn = $('startLive');
const stopLiveBtn = $('stopLive');
const video = $('video');
const modeText = $('modeText');
const statusDot = $('statusDot');
const qDot = $('qDot');
const qLabel = $('qLabel');
const shapeBadge = $('shapeBadge');
const insightsEl = $('insights');

areaRange.addEventListener('input', () => {
  areaLabel.textContent = areaRange.value + '%';
  saveSettings();
});
blurRange.addEventListener('input', () => {
  blurLabel.textContent = blurRange.value;
  saveSettings();
});
rollThreshInput.addEventListener('input', saveSettings);
yawThreshInput.addEventListener('input', saveSettings);

let sourceCanvas = null;
let lastResult = {};
const MAX_UPLOAD_BYTES = 8 * 1024 * 1024;

let faceMesh = null;
let faceMeshReady = false;
let analyzing = false;
let liveMode = false;
let liveStream = null;

(function initFaceMesh() {
  try {
    faceMesh = new FaceMesh({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
    });
    faceMesh.setOptions({
      maxNumFaces: 2,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    faceMesh.onResults(handleResults);
    faceMeshReady = true;
  } catch (e) {
    faceMeshReady = false;
    showBanner(false, 'Error loading face model. Check your connection.');
    console.error(e);
  }
})();

async function readImageOrientation(file) {
  if (!file || !file.type || (!file.type.includes('jpeg') && !file.type.includes('jpg'))) return 1;
  const arr = await file.arrayBuffer();
  const view = new DataView(arr);
  if (view.getUint16(0, false) !== 0xFFD8) return 1;
  let offset = 2;
  const len = view.byteLength;
  while (offset < len) {
    const marker = view.getUint16(offset, false);
    offset += 2;
    if (marker === 0xFFE1) {
      const exifHeader = getString(view, offset + 2, 4);
      if (exifHeader !== 'Exif') return 1;
      const tiffOffset = offset + 10;
      const little = view.getUint16(tiffOffset, false) === 0x4949;
      const firstIFD = view.getUint32(tiffOffset + 4, little);
      let dirOffset = tiffOffset + firstIFD;
      const entries = view.getUint16(dirOffset, little);
      dirOffset += 2;
      for (let i = 0; i < entries; i++) {
        const tag = view.getUint16(dirOffset + i * 12, little);
        if (tag === 0x0112) {
          const val = view.getUint16(dirOffset + i * 12 + 8, little);
          return val;
        }
      }
    } else {
      offset += view.getUint16(offset, false);
    }
  }
  return 1;
}
function getString(view, start, len) {
  let s = '';
  for (let i = 0; i < len; i++) s += String.fromCharCode(view.getUint8(start + i));
  return s;
}

function drawImageWithOrientation(img, orientation) {
  const c = document.createElement('canvas');
  let w = img.naturalWidth, h = img.naturalHeight;
  if (orientation === 6 || orientation === 8) {
    c.width = h;
    c.height = w;
  } else {
    c.width = w;
    c.height = h;
  }
  const cx = c.getContext('2d');
  cx.save();
  if (orientation === 3) {
    cx.translate(c.width, c.height);
    cx.rotate(Math.PI);
    cx.drawImage(img, 0, 0);
  } else if (orientation === 6) {
    cx.translate(c.width, 0);
    cx.rotate(Math.PI / 2);
    cx.drawImage(img, 0, 0);
  } else if (orientation === 8) {
    cx.translate(0, c.height);
    cx.rotate(-Math.PI / 2);
    cx.drawImage(img, 0, 0);
  } else {
    cx.drawImage(img, 0, 0);
  }
  cx.restore();
  return c;
}

function laplacianVariance(canvas, downscale = 0.25) {
  const w = Math.max(32, Math.round(canvas.width * downscale));
  const h = Math.max(32, Math.round(canvas.height * downscale));
  const tmp = document.createElement('canvas');
  tmp.width = w;
  tmp.height = h;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(canvas, 0, 0, w, h);
  const im = tctx.getImageData(0, 0, w, h);
  const gray = new Float32Array(w * h);
  for (let i = 0, j = 0; i < im.data.length; i += 4, j++) {
    gray[j] = 0.299 * im.data[i] + 0.587 * im.data[i + 1] + 0.114 * im.data[i + 2];
  }
  let sum = 0, sum2 = 0, n = 0;
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const idx = y * w + x;
      const v = -gray[idx - w] - gray[idx - 1] - gray[idx + 1] - gray[idx + w] + 4 * gray[idx];
      sum += v;
      sum2 += v * v;
      n++;
    }
  }
  if (n === 0) return 0;
  const mean = sum / n;
  const variance = (sum2 / n) - (mean * mean);
  return variance;
}

function laplacianVarianceBox(canvas, box, downscale = 0.25) {
  if (!box || box.w <= 0 || box.h <= 0) return laplacianVariance(canvas, downscale);
  const tmp = document.createElement('canvas');
  const w = Math.max(32, Math.round(box.w * downscale));
  const h = Math.max(32, Math.round(box.h * downscale));
  tmp.width = w;
  tmp.height = h;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(canvas, box.x, box.y, box.w, box.h, 0, 0, w, h);
  return laplacianVariance(tmp, 1);
}

const IDX = {
  leftEye: 33,
  rightEye: 263,
  noseTip: 1,
  chin: 152,
  leftJaw: 127,
  rightJaw: 356,
  forehead: 10
};

function computeBoxFromLM(landmarks, canvasEl) {
  let minX = 1, minY = 1, maxX = 0, maxY = 0;
  for (const p of landmarks) {
    if (!isFinite(p.x) || !isFinite(p.y)) continue;
    minX = Math.min(minX, p.x);
    minY = Math.min(minY, p.y);
    maxX = Math.max(maxX, p.x);
    maxY = Math.max(maxY, p.y);
  }
  const w = canvasEl.width;
  const h = canvasEl.height;
  return {
    x: minX * w,
    y: minY * h,
    w: Math.max(0, (maxX - minX) * w),
    h: Math.max(0, (maxY - minY) * h)
  };
}

function interEyeDistance(landmarks, srcCanvas) {
  const a = landmarks[IDX.leftEye];
  const b = landmarks[IDX.rightEye];
  if (!a || !b) return null;
  const dx = (a.x - b.x) * srcCanvas.width;
  const dy = (a.y - b.y) * srcCanvas.height;
  return Math.hypot(dx, dy);
}

function computeRollDeg(landmarks) {
  const a = landmarks[IDX.leftEye];
  const b = landmarks[IDX.rightEye];
  if (!a || !b) return 0;
  const angle = Math.atan2(b.y - a.y, b.x - a.x);
  return angle * 180 / Math.PI;
}

function approximateYawDeg(landmarks) {
  const a = landmarks[IDX.leftEye];
  const b = landmarks[IDX.rightEye];
  const n = landmarks[IDX.noseTip];
  if (!a || !b || !n) return 0;
  const midX = (a.x + b.x) / 2;
  const dx = n.x - midX;
  return dx * 180;
}

function jawAngleDeg(landmarks) {
  const L = landmarks[IDX.leftJaw];
  const R = landmarks[IDX.rightJaw];
  const C = landmarks[IDX.chin];
  if (!L || !R || !C) return null;
  const v1 = { x: L.x - C.x, y: L.y - C.y };
  const v2 = { x: R.x - C.x, y: R.y - C.y };
  const dot = v1.x * v2.x + v1.y * v2.y;
  const mag = Math.hypot(v1.x, v1.y) * Math.hypot(v2.x, v2.y);
  if (mag === 0) return null;
  const cos = Math.max(-1, Math.min(1, dot / mag));
  const angle = Math.acos(cos);
  return angle * 180 / Math.PI;
}

function coreLandmarksPresent(landmarks) {
  for (const k of Object.values(IDX)) {
    if (!landmarks[k] || !isFinite(landmarks[k].x) || !isFinite(landmarks[k].y)) return false;
  }
  return true;
}

function measureFace(landmarks) {
  let minY = 1, maxY = 0;
  for (const p of landmarks) {
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  const heightN = maxY - minY;
  if (!(heightN > 0)) return null;
  const yTop = minY + 0.12 * heightN;
  const yCheek = minY + 0.45 * heightN;
  const yJaw = minY + 0.82 * heightN;
  function widthAtY(yTarget) {
    let left = 1, right = 0, band = 0.015;
    for (let attempt = 0; attempt < 6; attempt++) {
      left = 1;
      right = 0;
      let found = false;
      for (const p of landmarks) {
        if (Math.abs(p.y - yTarget) <= band) {
          left = Math.min(left, p.x);
          right = Math.max(right, p.x);
          found = true;
        }
      }
      if (found) break;
      band *= 2;
    }
    if (left >= right) {
      let minX = 1, maxX = 0;
      for (const p of landmarks) {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
      }
      return { normW: maxX - minX };
    }
    return { normW: right - left };
  }
  const topW = widthAtY(yTop);
  const cheekW = widthAtY(yCheek);
  const jawW = widthAtY(yJaw);
  const measure = {
    topNorm: topW.normW,
    cheekNorm: cheekW.normW,
    jawNorm: jawW.normW,
    lengthNorm: heightN
  };
  const avgW = (measure.topNorm + measure.cheekNorm + measure.jawNorm) / 3;
  measure.lenOverW = avgW > 0 ? (measure.lengthNorm / avgW) : null;
  measure.jawToCheek = measure.cheekNorm > 0 ? (measure.jawNorm / measure.cheekNorm) : null;
  measure.topToCheek = measure.cheekNorm > 0 ? (measure.topNorm / measure.cheekNorm) : null;
  return measure;
}

function classifyShape(measure) {
  if (!measure || measure.lenOverW == null) return { shape: 'unknown', reason: 'no_measure' };
  const top = measure.topNorm;
  const cheek = measure.cheekNorm;
  const jaw = measure.jawNorm;
  const lenOverW = measure.lenOverW;
  const jawToCheek = measure.jawToCheek;
  const topToCheek = measure.topToCheek;

  if (lenOverW > 1.45) return { shape: 'oblong/long', reason: `len/width≈${lenOverW.toFixed(2)}` };
  if (lenOverW >= 0.95 && lenOverW <= 1.15 && Math.abs(top - cheek) < 0.06 && Math.abs(cheek - jaw) < 0.06) {
    return { shape: 'round', reason: `balanced width & length (len/width≈${lenOverW.toFixed(2)})` };
  }
  if (lenOverW >= 0.95 && lenOverW <= 1.15 && jawToCheek && Math.abs(jawToCheek - 1) < 0.08) {
    return { shape: 'square', reason: `strong jaw (jaw/cheek≈${jawToCheek.toFixed(2)})` };
  }
  if (topToCheek && jawToCheek && topToCheek > 1.06 && jawToCheek < 0.9) {
    return { shape: 'heart', reason: `wider forehead, narrower jaw` };
  }
  if (cheek > top && cheek > jaw && Math.abs(top - jaw) < 0.12) {
    return { shape: 'diamond', reason: `widest at cheekbones` };
  }
  if (lenOverW > 1.15 && jawToCheek && jawToCheek < 0.95) {
    return { shape: 'oval', reason: `longer face, softer jaw` };
  }
  if (lenOverW > 1.15) {
    return { shape: 'oval', reason: `fallback len/width≈${lenOverW.toFixed(2)}` };
  }
  return { shape: 'unknown', reason: 'no_match_heuristic' };
}

function mapPointToPreview(p) {
  const sx = preview.width / (sourceCanvas ? sourceCanvas.width : 1);
  const sy = preview.height / (sourceCanvas ? sourceCanvas.height : 1);
  return {
    x: p.x * (sourceCanvas ? sourceCanvas.width : 0) * sx,
    y: p.y * (sourceCanvas ? sourceCanvas.height : 0) * sy
  };
}

function drawMeasureGuides(landmarks) {
  if (!landmarks || !sourceCanvas) return;
  let minY = 1, maxY = 0;
  for (const p of landmarks) {
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  const heightN = maxY - minY;
  if (!(heightN > 0)) return;
  const yTop = minY + 0.12 * heightN;
  const yCheek = minY + 0.45 * heightN;
  const yJaw = minY + 0.82 * heightN;

  const sy = preview.height / (sourceCanvas ? sourceCanvas.height : 1);

  ctx.lineWidth = 2;
  const colors = ['#f59e0b', '#06b6d4', '#ef4444'];
  const labels = ['Top', 'Cheek', 'Jaw'];
  [yTop, yCheek, yJaw].forEach((yN, i) => {
    const yPx = yN * (sourceCanvas ? sourceCanvas.height : 0) * sy;
    ctx.strokeStyle = colors[i];
    ctx.beginPath();
    ctx.moveTo(8, yPx);
    ctx.lineTo(preview.width - 8, yPx);
    ctx.stroke();
    ctx.fillStyle = colors[i];
    ctx.font = '12px sans-serif';
    ctx.fillText(labels[i], 12, yPx - 6);
  });
}

function drawOverlay(landmarks) {
  ctx.clearRect(0, 0, overlay.width, overlay.height);
  if (!landmarks || !sourceCanvas) return;

  ctx.fillStyle = '#FFDD77';
  ctx.beginPath();
  for (const p of landmarks) {
    const pt = mapPointToPreview(p);
    ctx.moveTo(pt.x + 1, pt.y);
    ctx.arc(pt.x, pt.y, 1.4, 0, Math.PI * 2);
  }
  ctx.fill();

  const box = computeBoxFromLM(landmarks, sourceCanvas);
  const sx = preview.width / sourceCanvas.width;
  const sy = preview.height / sourceCanvas.height;
  ctx.strokeStyle = '#06b6d4';
  ctx.lineWidth = 2;
  ctx.strokeRect(box.x * sx, box.y * sy, box.w * sx, box.h * sy);

  const keys = ['leftEye', 'rightEye', 'noseTip', 'chin', 'leftJaw', 'rightJaw', 'forehead'];
  ctx.fillStyle = '#fff';
  keys.forEach(k => {
    const idx = IDX[k];
    if (!landmarks[idx]) return;
    const pt = mapPointToPreview(landmarks[idx]);
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 3.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.font = '11px sans-serif';
    ctx.fillText(k, pt.x + 6, pt.y + 3);
    ctx.fillStyle = '#fff';
  });

  drawMeasureGuides(landmarks);
}

function evaluateResult(results) {
  const areaPct = parseFloat(areaRange.value);
  const blurThresh = parseFloat(blurRange.value);
  const rollThresh = Math.abs(parseFloat(rollThreshInput.value) || 20);
  const yawThresh = Math.abs(parseFloat(yawThreshInput.value) || 15);

  const faces = results.multiFaceLandmarks || [];
  const json = {
    accepted: false,
    reason: 'no_face',
    faces: faces.length,
    checks: {},
    features: {}
  };

  if (!sourceCanvas) {
    json.reason = 'no_source';
    return json;
  }
  if (!Array.isArray(faces) || faces.length === 0) {
    json.reason = 'no_face';
    return json;
  }
  if (faces.length !== 1) {
    json.reason = 'multiple_faces';
    return json;
  }

  const lm = faces[0];

  json.features.corePresent = coreLandmarksPresent(lm);
  if (!json.features.corePresent) {
    json.reason = 'core_landmarks_missing';
    return json;
  }

  const box = computeBoxFromLM(lm, sourceCanvas);
  json.features.bbox = box;
  json.checks.boxPixels = box.w * box.h;
  const imageArea = sourceCanvas.width * sourceCanvas.height;
  const requiredArea = (areaPct / 100) * imageArea;
  json.checks.requiredArea = requiredArea;
  if (box.w <= 10 || box.h <= 10) {
    json.reason = 'bbox_too_small_pixels';
    return json;
  }
  if (json.checks.boxPixels < requiredArea) {
    json.reason = 'face_too_small_area';
    return json;
  }

  const blurVar = laplacianVarianceBox(sourceCanvas, box, 0.25);
  json.features.blurVariance = blurVar;
  if (blurVar < blurThresh) {
    json.reason = 'image_too_blurry';
    return json;
  }

  const eyeDist = interEyeDistance(lm, sourceCanvas);
  json.features.interEye = eyeDist;
  if (!eyeDist || eyeDist < 6) {
    json.reason = 'invalid_eye_distance';
    return json;
  }

  const roll = computeRollDeg(lm);
  const yawDeg = approximateYawDeg(lm);
  json.features.rollDeg = roll;
  json.features.yawDeg = yawDeg;
  if (Math.abs(roll) > rollThresh) {
    json.reason = 'face_tilted_roll';
    return json;
  }
  if (Math.abs(yawDeg) > yawThresh) {
    json.reason = 'face_yawed_side';
    return json;
  }

  const jawAng = jawAngleDeg(lm);
  json.features.jawAngleDeg = jawAng;
  if (!jawAng || !isFinite(jawAng)) {
    json.reason = 'invalid_jaw_angle';
    return json;
  }

  const measure = measureFace(lm);
  json.features.measure = measure;
  const cls = classifyShape(measure);
  json.features.shape = cls;
  json.shape = cls.shape;

  json.features.boxAspect = box.w > 0 ? (box.h / box.w) : null;
  json.features.boxAreaRatio = imageArea > 0 ? (json.checks.boxPixels / imageArea) : null;

  const blurScore = Math.max(0, Math.min(1, (blurVar - blurThresh) / (blurThresh || 1)));
  const areaRatio = json.features.boxAreaRatio || 0;
  const minAreaRatio = requiredArea / (imageArea || 1);
  const areaScore = Math.max(0, Math.min(1, (areaRatio - minAreaRatio) / (minAreaRatio || 1)));
  const rollScore = 1 - Math.min(1, Math.abs(roll) / (rollThresh || 1));
  const yawScore = 1 - Math.min(1, Math.abs(yawDeg) / (yawThresh || 1));
  const qualityScore = (blurScore + areaScore + rollScore + yawScore) / 4;
  json.features.qualityScore = qualityScore;

  json.accepted = true;
  json.reason = 'one_face_detected';

  return json;
}

function handleResults(results) {
  hideSpinner();
  const evalJson = evaluateResult(results);
  lastResult = evalJson;
  jsonOut.textContent = JSON.stringify(evalJson, null, 2);

  const shape = evalJson.shape || '—';
  shapeText.textContent = 'Face shape: ' + shape;

  const q = evalJson.features && typeof evalJson.features.qualityScore === 'number'
    ? Math.round(evalJson.features.qualityScore * 100)
    : null;
  qualityText.textContent = 'Quality score: ' + (q != null ? (q + '/100') : '—');

  if (evalJson.features) {
    const f = evalJson.features;
    const areaRatio = f.boxAreaRatio != null ? f.boxAreaRatio.toFixed(3) : '—';
    const blurVar = f.blurVariance != null ? f.blurVariance.toFixed(1) : '—';
    const roll = f.rollDeg != null ? f.rollDeg.toFixed(1) + '°' : '—';
    const yaw = f.yawDeg != null ? f.yawDeg.toFixed(1) + '°' : '—';
    const jaw = f.jawAngleDeg != null ? f.jawAngleDeg.toFixed(1) + '°' : '—';
    metrics.textContent = `Area ratio: ${areaRatio} | Blur: ${blurVar} | Roll: ${roll} | Yaw: ${yaw} | Jaw: ${jaw}`;
  } else {
    metrics.textContent = 'Area ratio: — | Blur: — | Roll: — | Yaw: — | Jaw: —°';
  }

  updateQualityBadge(evalJson);
  updateInsights(evalJson);

  if (!evalJson.accepted) {
    const reasonText = readableReason(evalJson.reason);
    summaryText.textContent = 'Rejected: ' + reasonText;
    showBanner(false, reasonText);
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      drawOverlay(results.multiFaceLandmarks[0]);
    } else {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
    }
    return;
  }

  const shapeReason = evalJson.features && evalJson.features.shape && evalJson.features.shape.reason
    ? evalJson.features.shape.reason
    : '';
  const parts = [];
  parts.push('Accepted single-face image with good detection quality.');
  if (shape !== '—' && shape !== 'unknown') parts.push('Detected shape: ' + shape + '.');
  if (shapeReason) parts.push('Shape reasoning: ' + shapeReason + '.');
  if (q != null) parts.push('Overall quality score: ' + q + '/100.');

  summaryText.textContent = parts.join(' ');
  showBanner(true, 'ACCEPTED — ' + (shape || '—').toUpperCase());

  if (results.multiFaceLandmarks && results.multiFaceLandmarks[0]) {
    drawOverlay(results.multiFaceLandmarks[0]);
  }
}

function updateQualityBadge(json) {
  if (!json || !json.features || typeof json.features.qualityScore !== 'number') {
    qDot.style.background = '#6b7280';
    qLabel.textContent = 'Idle';
    return;
  }
  const q = Math.round(json.features.qualityScore * 100);
  let color = '#22c55e';
  let label = 'High quality';
  if (q < 40) {
    color = '#ef4444';
    label = 'Very low quality';
  } else if (q < 70) {
    color = '#eab308';
    label = 'Medium quality';
  }
  qDot.style.background = color;
  qLabel.textContent = label + ' (' + q + '/100)';
  if (json.shape && json.shape !== 'unknown') {
    shapeBadge.style.display = 'inline-flex';
    shapeBadge.textContent = 'Shape: ' + json.shape;
  } else {
    shapeBadge.style.display = 'none';
  }
}

function updateInsights(json) {
  const lines = [];
  if (!json || !json.features) {
    insightsEl.innerHTML = '<li>Start the camera or upload a photo to see tailored tips.</li>';
    return;
  }

  const shape = json.shape || 'unknown';
  const q = typeof json.features.qualityScore === 'number' ? Math.round(json.features.qualityScore * 100) : null;
  const yaw = json.features.yawDeg || 0;
  const roll = json.features.rollDeg || 0;

  if (shape === 'oval') {
    lines.push('Your face is slightly longer than it is wide with a softer jaw. Most hairstyles and glasses shapes will suit you.');
    lines.push('Try rectangular or square frames to add structure around the eyes.');
  } else if (shape === 'round') {
    lines.push('Your face has similar width and length with soft curves. Angular styles will give more definition.');
    lines.push('Hairstyles with volume on top and less on the sides can lengthen the look of your face.');
  } else if (shape === 'square') {
    lines.push('You have a strong, defined jawline. Softer, rounder frames and layered hair help balance the sharp angles.');
  } else if (shape === 'heart') {
    lines.push('Your forehead appears wider with a narrower chin. Light frames and styles that add volume near the jaw work well.');
  } else if (shape === 'diamond') {
    lines.push('Your cheekbones are the widest point. Avoid very narrow glasses; slightly rounded shapes can balance your features.');
  } else if (shape === 'oblong/long') {
    lines.push('Your face is noticeably longer than it is wide. Frames or hairstyles that add width at the sides suit you.');
  } else {
    lines.push('Shape is not confidently classified. Try adjusting lighting and facing the camera directly for a clearer scan.');
  }

  if (q != null) {
    if (q < 40) {
      lines.push('Detection quality is low. Improve room lighting and bring the camera slightly closer.');
    } else if (q < 70) {
      lines.push('Detection quality is moderate. A bit more light or sharper focus can give better results.');
    } else {
      lines.push('Detection quality is high. This image is suitable for verification or profile photos.');
    }
  }

  if (Math.abs(yaw) > 5) {
    lines.push('Your face is turned slightly to the side. Look straight at the camera for best symmetry analysis.');
  }
  if (Math.abs(roll) > 5) {
    lines.push('Your head is slightly tilted. Keep it upright to avoid distortion in shape estimation.');
  }

  insightsEl.innerHTML = '';
  lines.forEach(t => {
    const li = document.createElement('li');
    li.textContent = t;
    insightsEl.appendChild(li);
  });
}

function readableReason(code) {
  const map = {
    no_source: 'No source frame available.',
    no_face: 'No face found — come closer or improve lighting.',
    multiple_faces: 'Multiple faces detected — use a single-face frame.',
    core_landmarks_missing: 'Essential landmarks missing — face the camera directly.',
    bbox_too_small_pixels: 'Detected face too small in pixels.',
    face_too_small_area: 'Face area too small — move closer to the camera.',
    image_too_blurry: 'Image is too blurry — use a sharper frame or better focus.',
    invalid_eye_distance: 'Invalid inter-eye distance — detection unstable.',
    face_tilted_roll: 'Face is tilted — keep your head straight.',
    face_yawed_side: 'Face turned sideways — look straight at the camera.',
    invalid_jaw_angle: 'Invalid jaw angle — use a frontal view.',
    invalid_image_or_too_large: 'Invalid image or file too large.',
    file_too_large: 'File too large (max 8MB).',
    invalid_image: 'Invalid image.',
    processing_error: 'Processing error.'
  };
  return map[code] || (code || 'Unknown reason');
}

async function runFaceMesh() {
  if (!sourceCanvas) {
    showBanner(false, 'No image to analyze.');
    return;
  }
  if (!faceMeshReady || !faceMesh) {
    showBanner(false, 'Face model not ready.');
    return;
  }
  if (analyzing) return;
  analyzing = true;
  showSpinner();
  try {
    await faceMesh.send({ image: sourceCanvas });
  } catch (e) {
    console.error(e);
    showBanner(false, 'Error during analysis.');
  } finally {
    analyzing = false;
    hideSpinner();
  }
}

upload.addEventListener('change', async (e) => {
  stopLiveMode();
  resetUI();
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  if (f.size > MAX_UPLOAD_BYTES) {
    showBanner(false, 'File too large (max 8MB)');
    jsonOut.textContent = JSON.stringify({ accepted: false, reason: 'file_too_large' }, null, 2);
    return;
  }

  showSpinner();
  try {
    const ori = await readImageOrientation(f).catch(() => 1);
    const img = new Image();
    const url = URL.createObjectURL(f);
    img.onload = async () => {
      URL.revokeObjectURL(url);
      sourceCanvas = drawImageWithOrientation(img, ori);
      fitPreviewToStage();
      pctx.clearRect(0, 0, preview.width, preview.height);
      const sx = preview.width / sourceCanvas.width;
      const sy = preview.height / sourceCanvas.height;
      pctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, sourceCanvas.width * sx, sourceCanvas.height * sy);
      await runFaceMesh();
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      hideSpinner();
      showBanner(false, 'Invalid image');
      jsonOut.textContent = JSON.stringify({ accepted: false, reason: 'invalid_image' }, null, 2);
    };
    img.src = url;
  } catch (err) {
    hideSpinner();
    console.error(err);
    showBanner(false, 'Processing error');
    jsonOut.textContent = JSON.stringify({ accepted: false, reason: 'processing_error', error: String(err) }, null, 2);
  }
});

recheckBtn.addEventListener('click', async () => {
  clearBanner();
  ctx.clearRect(0, 0, overlay.width, overlay.height);
  if (!sourceCanvas) {
    showBanner(false, 'No image to recheck');
    return;
  }
  fitPreviewToStage();
  pctx.clearRect(0, 0, preview.width, preview.height);
  const sx = preview.width / sourceCanvas.width;
  const sy = preview.height / sourceCanvas.height;
  pctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, sourceCanvas.width * sx, sourceCanvas.height * sy);
  await runFaceMesh();
});

clearBtn.addEventListener('click', () => {
  stopLiveMode();
  sourceCanvas = null;
  resetUI();
});

copyJsonBtn.addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(jsonOut.textContent);
    showBanner(true, 'JSON copied to clipboard');
  } catch {
    showBanner(false, 'Unable to copy JSON');
  }
});

function fitPreviewToStage() {
  if (!sourceCanvas) return;
  const stage = $('stage');
  const rect = stage.getBoundingClientRect();
  const maxW = rect.width;
  const maxH = rect.height;
  const scale = Math.min(maxW / sourceCanvas.width, maxH / sourceCanvas.height);
  const cssW = sourceCanvas.width * scale;
  const cssH = sourceCanvas.height * scale;
  const ratio = window.devicePixelRatio || 1;

  preview.style.width = cssW + 'px';
  preview.style.height = cssH + 'px';
  overlay.style.width = cssW + 'px';
  overlay.style.height = cssH + 'px';

  preview.width = Math.round(cssW * ratio);
  preview.height = Math.round(cssH * ratio);
  overlay.width = Math.round(cssW * ratio);
  overlay.height = Math.round(cssH * ratio);
}

function showSpinner() {
  spinner.style.display = 'block';
}
function hideSpinner() {
  spinner.style.display = 'none';
}
function showBanner(ok, text) {
  banner.style.display = 'block';
  banner.textContent = text;
  banner.className = 'banner ' + (ok ? 'ok' : 'bad');
}
function clearBanner() {
  banner.style.display = 'none';
  banner.textContent = '';
  banner.className = 'banner';
}

function saveSettings() {
  const settings = {
    area: areaRange.value,
    blur: blurRange.value,
    roll: rollThreshInput.value,
    yaw: yawThreshInput.value
  };
  try {
    localStorage.setItem('faceLookSettings', JSON.stringify(settings));
  } catch {}
}
(function loadSettings() {
  try {
    const raw = localStorage.getItem('faceLookSettings');
    if (!raw) return;
    const s = JSON.parse(raw);
    if (s.area) areaRange.value = s.area;
    if (s.blur) blurRange.value = s.blur;
    if (s.roll) rollThreshInput.value = s.roll;
    if (s.yaw) yawThreshInput.value = s.yaw;
    areaLabel.textContent = areaRange.value + '%';
    blurLabel.textContent = blurRange.value;
  } catch {}
})();

function resetUI() {
  pctx.fillStyle = '#020617';
  pctx.fillRect(0, 0, preview.width, preview.height);
  ctx.clearRect(0, 0, overlay.width, overlay.height);
  pctx.fillStyle = '#6b7280';
  pctx.font = '13px sans-serif';
  pctx.fillText('Start live camera or upload an image', 14, 26);
  jsonOut.textContent = '{}';
  clearBanner();
  shapeText.textContent = 'Face shape: —';
  qualityText.textContent = 'Quality score: —';
  summaryText.textContent = 'No analysis yet.';
  metrics.textContent = 'Area ratio: — | Blur: — | Roll: — | Yaw: — | Jaw: —°';
  insightsEl.innerHTML = '<li>Start the camera or upload a photo to see tailored tips.</li>';
  qDot.style.background = '#6b7280';
  qLabel.textContent = 'Idle';
  shapeBadge.style.display = 'none';
  modeText.textContent = 'Idle';
  statusDot.style.background = '#ef4444';
}

startLiveBtn.addEventListener('click', async () => {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    showBanner(false, 'Camera not available in this browser.');
    return;
  }
  try {
    stopLiveMode();
    liveStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: false });
    video.srcObject = liveStream;
    await video.play();
    liveMode = true;
    modeText.textContent = 'Live';
    statusDot.style.background = '#22c55e';
    clearBanner();
    loopLive();
  } catch (e) {
    console.error(e);
    showBanner(false, 'Unable to access camera. Check permissions.');
  }
});

stopLiveBtn.addEventListener('click', () => {
  stopLiveMode();
});

function stopLiveMode() {
  liveMode = false;
  if (liveStream) {
    liveStream.getTracks().forEach(t => t.stop());
    liveStream = null;
  }
  modeText.textContent = 'Idle';
  statusDot.style.background = '#ef4444';
}

async function loopLive() {
  if (!liveMode) return;
  if (!video.videoWidth || !video.videoHeight) {
    requestAnimationFrame(loopLive);
    return;
  }
  if (!sourceCanvas) {
    sourceCanvas = document.createElement('canvas');
  }
  sourceCanvas.width = video.videoWidth;
  sourceCanvas.height = video.videoHeight;
  const sctx = sourceCanvas.getContext('2d');
  sctx.drawImage(video, 0, 0, sourceCanvas.width, sourceCanvas.height);

  fitPreviewToStage();
  pctx.clearRect(0, 0, preview.width, preview.height);
  const sx = preview.width / sourceCanvas.width;
  const sy = preview.height / sourceCanvas.height;
  pctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, sourceCanvas.width * sx, sourceCanvas.height * sy);

  if (!analyzing && faceMeshReady && faceMesh) {
    analyzing = true;
    try {
      await faceMesh.send({ image: sourceCanvas });
    } catch (e) {
      console.error(e);
    } finally {
      analyzing = false;
    }
  }
  requestAnimationFrame(loopLive);
}

(function init() {
  preview.width = 640;
  preview.height = 480;
  overlay.width = 640;
  overlay.height = 480;
  resetUI();
})();
</script>
</body>
</html>
